# COMP - Project 1

For this project, you need to [install Gradle](https://gradle.org/install/)

## Project setup

Copy your ``.jjt`` file to the ``javacc`` folder. If you change any of the classes generated by ``jjtree`` or ``javacc``, you also need to copy them to the ``javacc`` folder.

Copy your source files to the ``src`` folder, and your JUnit test files to the ``test`` folder.

## Compile

To compile the program, run ``gradle build``. This will compile your classes to ``classes/main/java`` and copy the JAR file to the root directory. The JAR file will have the same name as the repository folder.

### Run

To run you have two options: Run the ``.class`` files or run the JAR.

### Run ``.class``

To run the ``.class`` files, do the following:

```cmd
java -cp "./build/classes/java/main/" <class_name> <arguments>
```

Where ``<class_name>`` is the name of the class you want to run and ``<arguments>`` are the arguments to be passed to ``main()``.

### Run ``.jar``

To run the JAR, do the following command:

```cmd
java -jar <jar filename> <arguments>
```

Where ``<jar filename>`` is the name of the JAR file that has been copied to the root folder, and ``<arguments>`` are the arguments to be passed to ``main()``.

## Test

To test the program, run ``gradle test``. This will execute the build, and run the JUnit tests in the ``test`` folder. If you want to see output printed during the tests, use the flag ``-i`` (i.e., ``gradle test -i``).

## Checklist for checkpoint 2

- Symbol Table
  
    . global: inclui info de imports e a classe declarada [CHECK]

    . classe-specific: inclui info de extends, fields e methods [CHECK]

    . method-specific: inclui info dos arguments e local variables [CHECK]

    . sub topics:

       + tem de permitir method overload (i.e. métodos com mesmo nome mas assinatura de parâmetros diferente) [CHECK]
        
       + tem de permitir consulta da tabela por parte da análise semantica (e geração de código) [CHECK]
        
       + tem de permitir ligar e desligar a sua impressão para fins de debug (neste caso para fins de avaliação) [CHECK]
        
       > Nota: para habilitar/desabilitar a impressão da tabela de símbolos, basta alterar o valor da variável 'printSymbolTable' na classe Main. 
  
- Type Verification 
 
    . verificar se operações são efetuadas com o mesmo tipo (e.g. int + boolean tem de dar erro) [CHECK]

    . não é possível utilizar arrays diretamente para operações aritmeticas (e.g. array1 + array2) [CHECK]

    . verificar se um array access é de facto feito sobre um array [CHECK]

    . verificar se o indice do array access é um inteiro [CHECK]

    . verificar se valor do assignee é igual ao do assigned (a_int = b_boolean não é permitido!) [CHECK]

    . verificar se operação booleana é efetuada só com booleanos [CHECK]

    . verificar se conditional expressions (if e while) resulta num booleano [CHECK]

    . verificar se variáveis são inicializadas, dando um WARNING em vez de ERRO

       + parametros são assumidos como inicializados [CHECK]
  
       + devem fazer uma análise através do control flow, i.e., se há um if e a variável só é inicializada dentro de ou o then ou o else, deve-se dar um warning a indicar que poderá não estar inicializada [CHECK]
   
       + será considerado bónus a quem resolver esta verificação usando erros em vez de warning. [CHECK]
            - cuidado que se a analise não estiver bem feita os erros vão fazer com que o vosso compilador não passe para a geração de código!
			- caso pretendam fazer esta abordagem com erros adicionem uma forma de ativar/desativar o erro para facilitar no caso de haver problemas.

- Function Verification
  
	* verificar se o "target" do método existe, e se este contém o método (e.g. a.foo, ver se 'a' existe e se tem um método 'foo') [CHECK]
	    - caso seja do tipo da classe declarada (e.g. a usar o this), verificar se é método do extends olhando para o que foi importado (isto se a classe fizer extends de outra classe importada) [CHECK]
	* caso o método não seja da classe declarada, isto é importada, verificar se método foi importado [CHECK]
	* verificar se o número de argumentos na invocação é igual ao número de parâmetros da declaração [CHECK]
	* verificar se o tipo dos parâmetros coincide com o tipo dos argumentos [CHECK]
	    - não esquecer que existe method overloading 
  
- Code Generation

    * estrutura básica de classe (incluindo construtor <init>) [CHECK]
	* estrutura básica de fields [CHECK]
	* estrutura básica de métodos (podem desconsiderar os limites neste checkpoint: limit_stack 99, limit_locals 99) [CHECK]
	* assignments [CHECK]
	* operações aritméticas (com prioridade de operações correta) [CHECK]
		- neste checkpoint não é necessário a seleção das operações mais eficientes mas isto será considerado no CP3 e versão final
	* invocação de métodos [CHECK]
    
## Errors

There is a flag that controls whether the program should report variables not initialized as errors or just warnings. To activate the treatment
as error, the flag "-Ierror" should be used after the input file when executing the program. By default, the tests are running with the error treatment, since they expect for an exception to be thrown.


In addition, only one error is reported per line and in case a variable was not defined, the analyzer would detect that the variable was not 
defined nor declared. Our program only reports that the variable is not declared since it's the most useful information.
